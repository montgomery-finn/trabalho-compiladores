/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(CompiladorAula)

package parser;
import recovery.*;

public class CompiladorAula
{
  public static void main(String args []) throws ParseException
  {
    CompiladorAula parser = new CompiladorAula(System.in);
    while (true)
    {
      System.out.println("Escreva um program.a..");
      System.out.print("------ > ");

      SimpleNode n = CompiladorAula.main();
      n.dump(" ");
      try
      {
        /*switch (CompiladorAula.main())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Goodbye.");
          break;
          default : 
          break;
        }*/
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        CompiladorAula.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }

  static public String im(int x)
  {
    int k;
	String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {
      s = s.substring(1,k);
    }
   catch (StringIndexOutOfBoundsException e)
	   {}
   return s;
  }
	
  static Token lastError = null;
  static boolean eof;    // variável que indica se EOF foi alcançado
	
  // o método abaixo consome tokens até alcançar um que pertença ao conjunto
  // de sincronização
  static void consumeUntil(RecoverySet g,
	                 ParseException e,
	                 String met) throws ParseEOFException,
	                                    ParseException
  {
	Token tok;
	System.out.println();
	System.out.println("*** " + met + " ***");
	System.out.println("     Conjunto de sincronização: " + g);
		
	if (g == null) throw e; // se o conjunto é null, propaga a exceção
	
	tok = getToken(1); // pega token corrente
	while ( ! eof )	{ // se não chegou ao fim do arquivo
	  if ( g.contains(tok.kind)) {//achou um token no conjunto
	    System.out.println("     Encontrado token de sincronização: " + 
	                       im(tok.kind));
	    break;
	  }
	  System.out.println("     Ignorando o token: " + im(tok.kind));
	  getNextToken();     // pega próximo token       
      tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	      eof = true;
	}
    if ( tok != lastError)  {
	  System.out.println(e.getMessage());
	  lastError = tok;
	   
	}
	if ( eof )
	  throw new ParseEOFException("Encontrei EOF onde não deveria.");
  }
}

PARSER_END(CompiladorAula)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN :
{
  < ERAUMAVEZ : "eraUmaVez" >
| < EVIVERAMFELIZESPARASEMPRE : "eViveramFelizesParaSempre" >




| < PONTOEVIRGULA : ";" >
| < VIRGULA : "," >
| < IGUAL : "==" >
| < MAIORIGUAL : ">=" >
| < MENORIGUAL : "<=" >
| < DIFERENTE : "!=" >
| < E : "&&" >
| < OU : "||" >
| < MAIOR : " >" >
| < MENOR : "< " >
| < RECEBE : "=" >
| < ABREPARENTESES : "(" >
| < FECHAPARENTESES : ")" >
| < ABRECHAVES : "{" >
| < FECHACHAVES : "}" > 




| < TIPOINTEIRO : "inteiro" >
| < TIPOBOOLEANO : "booleano" >
| < TIPOCARACTER : "caracter" >



| < FALSO : "falso" >
| < VERDADEIRO : "verdadeiro" >


| < SE : "se" >
| < ENQUANTO: "enquanto" >



| < ID : < LETRA >(< LETRA > | < DIGITO >)* >


| < DECIMAL : (< DIGITO >)+ >
| < DIGITO : [ "0"-"9" ] >
| < LETRA: ["A"-"Z"] | ["a"-"z"] >
| < CARACTER : "'" (< LETRA > | < DIGITO >) "'">
}

SimpleNode main() :
{}
{
	eraUmaVez()
		bloco()
	eViveramFelizesParaSempre()
{ return jjtThis; }
}

void eraUmaVez():
{ }
{
	< ERAUMAVEZ >
}

void eViveramFelizesParaSempre():
{ }
{
	< EVIVERAMFELIZESPARASEMPRE >
}

void bloco():
{ }
{
	(tipoDeDadoEDecalaracaoDeVariaveis() | condicional())*  
}




//declaracao de variaveis
void tipoDeDadoEDecalaracaoDeVariaveis():
{ }
{
  tipoDado() umaOuMaisvariaveisComOuSemAtribuicaoSeguidasDePontoEVirgula()
}


void umaOuMaisvariaveisComOuSemAtribuicaoSeguidasDePontoEVirgula():
{ }
{
  id() atribuicaoDeValorOuDeclaracaoDeOutraVariavelOuPontoEVirgula()
}

void atribuicaoDeValorOuDeclaracaoDeOutraVariavelOuPontoEVirgula():
{ }
{
	(recebe() valor() declaracaoDeOutraVariavelOuPontoEVirgula()) | declaracaoDeOutraVariavelOuPontoEVirgula() 
}

void declaracaoDeOutraVariavelOuPontoEVirgula():
{ }
{
  pontoEVirgula() | (virgula() umaOuMaisvariaveisComOuSemAtribuicaoSeguidasDePontoEVirgula())
}



//condicional
void condicional():
{ }
{
	se() abreParenteses() expressaoLogicaFechaParenteses() abreChaves()
		bloco()
	fechaChaves()
}

void expressaoLogicaFechaParenteses():
{ }
{
	idOuValor() continuaExpressaoLogicaOuFechaParenteses() 
}

void continuaExpressaoLogicaOuFechaParenteses():
{ }
{
	fechaParenteses() | (operadorLogico() expressaoLogicaFechaParenteses())
}

void idOuValor():
{ }
{
	id() | valor()
}

void operadorLogico():
{ }
{
	igual() | maiorIgual() | menorIgual() | maior() | menor()
}


void valorBooleano():
{ }
{
	verdadeiro() | falso()
}

void valor():
{ }
{
	< DECIMAL > | valorBooleano()
}

void tipoDado() :
{}
{
	tipoInteiro() | tipoBooleano() | tipoCaracter()
}




//terminais
void pontoEVirgula():
{ }
{
  < PONTOEVIRGULA >
}

void virgula():
{ }
{
	< VIRGULA >
}

void id():
{ }
{
  < ID >
}

void tipoInteiro():
{}
{
	< TIPOINTEIRO > 
}

void tipoBooleano():
{ }
{
  < TIPOBOOLEANO >
}

void tipoCaracter():
{ }
{
	< TIPOCARACTER >
}

void se():
{}
{
	< SE >
}

void abreParenteses():
{}
{
	< ABREPARENTESES >
}

void fechaParenteses():
{}
{
	< FECHAPARENTESES >
}

void igual():
{}
{
	< IGUAL >
}

void maiorIgual():
{}
{
  < MAIORIGUAL >
}

void menorIgual():
{ }
{
	< MENORIGUAL >
}

void diferente():
{ }
{
	< DIFERENTE >
}

void e():
{ }
{
	< E >
}

void ou():
{ }
{
	< OU >
}

void maior():
{}
{
	< MAIOR >
}

void menor():
{}
{
	< MENOR >
}

void recebe():
{}
{
	< RECEBE >
}

void verdadeiro():
{ }
{
	< VERDADEIRO >
}

void falso():
{ }
{
	< FALSO >
}

void abreChaves():
{ }
{
	< ABRECHAVES >
}

void fechaChaves():
{ }
{
	< FECHACHAVES >
}

